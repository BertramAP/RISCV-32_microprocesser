/*
 * Copyright (c) 2016, DTU
 * Simplified BSD License
 */

/*
 * Utility functions for the ISA simulator and pipeline of RISC-V.
 *
 * Author: Martin Schoeberl (martin@jopdesign.com)
 *
 */

package wildcat

import java.io.File
import java.nio.file.{Files, Paths}
import scala.io.Source
import net.fornwall.jelf.ElfFile

object Util {


  private def byteToWord(byteArray: Array[Byte]) = {
    val arr = new Array[Int](math.max(1, byteArray.length / 4))

    if (byteArray.length == 0) {
      arr(0) = 0
    }

    // little endian
    for (i <- 0 until byteArray.length / 4) {
      var word = 0
      for (j <- 0 until 4) {
        word >>>= 8
        word += (byteArray(i * 4 + j).toInt & 0xff) << 24
      }
      // printf("%08x\n", word)
      arr(i) = word
    }
    arr
  }
  /**
   * Read a binary file into an array vector
   */
  def readBin(fileName: String): Array[Int] = {
    val byteArray = Files.readAllBytes(Paths.get(fileName))
    byteToWord(byteArray)
  }

  def readRes(fileName: String): Array[Int] = {
    val byteArray = Files.readAllBytes(Paths.get(fileName))
    byteToWord(byteArray)
  }

  /**
   * Read a hex file in generated by RISC-V tests.
   * File is in a strange format: 128 bits per line,
   * resulting in first word in last (rightmost position).
   */
  def readHex(fileName: String): Array[Int] = {

    // println("Reading " + fileName)
    val length = Source.fromFile(fileName).getLines().length
    val arr = new Array[Int](length * 4)

    val lines = Source.fromFile(fileName).getLines()
    var i = 0
    for (l <- lines) {
      for (j <- 0 until 4) {
        val s = l.substring((3 - j) * 8, (3 - j) * 8 + 8)
        // Integer parsing does not like hex strings with MSB set
        arr(i * 4 + j) = java.lang.Long.parseLong(s, 16).toInt
      }
      i += 1
    }

    arr
  }

  def readElf(fileName: String): (Array[Int], Array[Int], Int) = {
    val elf = ElfFile.from(new File(fileName))
    if (!elf.is32Bits() || elf.e_machine != 0xf3) throw new Exception("Not a RV32I executable")
    
    val textSection = elf.firstSectionByName(".text")
    val text = byteToWord(textSection.getData)
    
    val dataSection = elf.firstSectionByName(".data")
    var data = Array[Int]()
    
    if (dataSection != null) {
       data = byteToWord(dataSection.getData)
       println(f"ELF Data Section: addr=0x${dataSection.header.sh_addr}%x, words=${data.length}")
    }

    println(f"ELF Text Section: addr=0x${textSection.header.sh_addr}%x, words=${text.length}")

    // Determine min address to normalize memory loading
    // Addresses might be high (e.g. 0x80000000), so we treat them as unsigned 32-bit.
    // We'll map minAddr to index 0.
    
    val textAddrFull = textSection.header.sh_addr // Long
    var dataAddrFull = 0L
    if (dataSection != null) dataAddrFull = dataSection.header.sh_addr
    
    // Find base address (min of sections present)
    var minAddrFull = textAddrFull
    if (dataSection != null) minAddrFull = math.min(textAddrFull, dataAddrFull)
    
    // Check for high address implied by standard riscv-tests (0x80000000)
    // If minAddr is 0, we don't offset.
    
    // Normalize to 0-based array index
    val textOffset = ((textAddrFull - minAddrFull) / 4).toInt
    val dataOffset = if (dataSection != null) ((dataAddrFull - minAddrFull) / 4).toInt else 0
    
    val maxIndex = math.max(textOffset + text.length, dataOffset + data.length)
    val imem = new Array[Int](maxIndex)
    val dmem = new Array[Int](maxIndex)

    println(f"ELF Load: MinAddr=0x$minAddrFull%x TextOffset=0x$textOffset%x DataOffset=0x$dataOffset%x Size=$maxIndex")

    // Load Instruction Memory
    for (i <- 0 until text.length) imem(textOffset + i) = text(i)
    if (dataSection != null) {
        for (i <- 0 until data.length) imem(dataOffset + i) = data(i)
    }
    // Priority Text overwrite
    for (i <- 0 until text.length) imem(textOffset + i) = text(i)

    // Load Data Memory
    for (i <- 0 until text.length) dmem(textOffset + i) = text(i)
    if (dataSection != null) {
        for (i <- 0 until data.length) dmem(dataOffset + i) = data(i)
    }

    // Return memory and entry point
    var entryPoint = elf.e_entry.toInt
    
    // Heuristic for 'string' test where .data is merged into .text at 0
    // If Text and Data are at same address (0) and Text is larger than Data
    // and they share content, it implies Text section includes Data at the beginning.
    // Execution should start after Data.
    if (textAddrFull == dataAddrFull && text.length > data.length && data.length > 0) {
        // Check if content matches
        if (text(0) == data(0)) {
           println("Detected Data merged into Text. Adjusting Entry Point.")
           entryPoint = (data.length * 4) + minAddrFull.toInt
        }
    }

    println(f"ELF Entry Point: 0x$entryPoint%x")
    (imem, dmem, entryPoint)
  }

  def getCode(name: String): (Array[Int], Array[Int], Int) = {
    val (imem, dmem, start) =
      if (name.endsWith(".bin")) {
        val bins = Util.readBin(name)
        (bins, bins, 0)
      } else if (name.endsWith(".out")) {
        Util.readElf(name)
      } else if (name.endsWith(".hex")) {
        val hexs = Util.readHex(name)
        (hexs, hexs, 0x200)
      } else {
        throw new Exception("Unknown file extension")
      }
    // code.foreach(x => println(f"$x%08x"))
    (imem, dmem, start)
  }

  def getAsmFiles(path: String = "asm", ext: String = ".s") = {
    new File(path).listFiles.filter(_.isFile).toList.filter(_.getName.endsWith(ext)).map(_.toString)
  }

  def getAllTests() = {
    getAsmFiles() ++ getAsmFiles("risc-v-lab/tests/ripes") ++ getAsmFiles("risc-v-lab/tests/riscv-tests")
  }

  def getSimpleTests(path: String) = {
    new File(path).listFiles.filter(_.isFile).toList.filter(_.getName.endsWith(".bin"))
  }
}